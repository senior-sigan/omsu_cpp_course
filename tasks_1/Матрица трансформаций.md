---
tag: матрицы
repl: https://replit.com/@IlyaSiganov/transformationmatrix
---

# Матрица Трансформаций
[Шаблон проекта в Repl](https://replit.com/@IlyaSiganov/transformationmatrix#main.c)  

В этой задаче вам нужно будет написать код, чтобы манипулировать координатами точки (вектора) с помощью матриц переходов в двумерном пространстве. Нужно будет генерировать матрицы для поворота, масштабирования, переноса и ничегонеделания. И применять эти операторы матрицы над точками.

В коде есть все комментарии и инструкции по тому, что нужно реализовать. А тесты помогут отладить код.

*(Код задания в конце страницы)*

## Матчасть  

В компьютерной графики есть задача по повороту, масштабированию и позиционированию текстур на канвасе. При разработке игр надо уметь переводить координаты мира в координаты экрана. Чтобы выполнять эти задачи используют ЛИНЕЙНУЮ АЛГЕБРУ!!! Для проецирования, поворотов и т.д, используют [матрицы переходов](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%B0) - это такие линейные операторы. Если взять координаты точки(вектора) и умножить их на специальную матрицу, то получится новая точка(вктор) с нужными свойствами. (Иногда я буду писать вектор, а иногда точка. Считайте эти два слова синонимами в этой задаче.)

Одна из главных фичей операторов-матриц – это возможность применить сразу несколько трансформаций за один раз. Допустим, мы хотим повернуть, потом перенести, и еще раз повернуть точку. Мы можем это написать так:

```c
// символ @ означает матричное умножение
point = rotation_op(45) @ point
point = translate_op(1, 4) @ point
point = rotation_op(30) @ point
```

Эта запись эквивалентна другой:

```c
point = (rotation_op(30) @ (translate_op(1, 4) @ (rotation_op(45) @ point)))
```

По правилу ассоциативности мы можем перегруппировать скобки и сделать сначала все умножения матриц-операторов:

```c
point = (rotation_op(30) @ translate_op(1, 4) @ rotation_op(45)) @ point
```

Очевидно, это эквивалентно

```c
transformation = rotation_op(30) @ translate_op(1, 4) @ rotation_op(45)
point = transformation @ point
```

PROFIT!

Но зачем?

Если вы хотите трансформировать одну точку, то разницы нет, но если вы хотите перенести миллион точек (читай, любую точку на экране вашего телефона), тогда вы ускоряете свой код в 3 раза - применяете один раз умножение над каждой точкой, вместо применения 3х умножений над каждой точкой!!! Это супер круто.

Кстати, это похоже на отложенное вычисление - вы по сути сохраняете действие в матрице и потом повторяете его много раз.

## Умножение матриц
Пусть даны две прямоугольные матрицы $A$ и $B$ размерности $l \times m$ и $m \times n$ соответсвенно.

$$
A = \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1m} \\ a_{21} & a_{22} & \cdots & a_{2m} \\ \vdots & \vdots & \ddots & \vdots \\ a_{l1} & a_{l2} & \cdots & a_{lm} \end{bmatrix},\;\;\; B = \begin{bmatrix} b_{11} & b_{12} & \cdots & b_{1n} \\ b_{21} & b_{22} & \cdots & b_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ b_{m1} & b_{m2} & \cdots & b_{mn} \end{bmatrix}.
$$

Тогда матрица $C$ размерностью $l \times n$: $C = \begin{bmatrix} c_{11} & c_{12} & \cdots & c_{1n} \\ c_{21} & c_{22} & \cdots & c_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ c_{l1} & c_{l2} & \cdots & c_{ln} \end{bmatrix},$

в которой: $c_{ij} = \sum_{r=1}^m a_{ir}b_{rj} \;\;\; \left(i=1, 2, \ldots l;\; j=1, 2, \ldots n \right).$ называется их произведением.

Операция умножения двух матриц выполнима только в том случае, если число столбцов в первом сомножителе равно числу строк во втором; в этом случае говорят, что матрицы согласованы. В частности, умножение всегда выполнимо, если оба сомножителя — квадратные матрицы одного и того же порядка.

Пример произведения строки на столбец:

![https://excel2.ru/sites/default/files/student-7.png](https://excel2.ru/sites/default/files/student-7.png)

Алгоритм умножения матриц $l \times m$ и $m \times n$ - это алгоритм O(n^3). У вас будет цикл вида:

```c
for (int i = 0; i < l; i++)
	for (int j = 0; j < n; j++)
		for (int k = 0; k < m; k++)
			// тут код умножения
```

## Матрица перехода  

Пусть дана точка $P_{(x,y)}$ двумерной плоскости с координатами $(x, y)$. Представим ее в виде вектор-столбца $\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$. Обратите внимание на единицу в третьей строке - она нужна для применения перемещение (переноса, translate) точки. Если бы у нас было трехмерное пространство, то вектор был бы размера 4.

### Оператор идентичности

Оператор идентичности ни делает ничего - он оставляет вектор(точку) таким, каким он был. Реализуется он с помощью единичной матрицы $E$ - это диагональная матрицы с 1 на диагонали. Единичная матрица обладает свойством: $A E = E A = A$. Такой оператор нам понадобится, чтобы на его основе создавать другие операторы.  

$$
E = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{bmatrix}
$$

### Оператор поворота

Чтобы повернуть точку вокруг начала координат (0, 0) на угол $\theta$, нужно вектор-столбец точки умножить **справа** на матрицу поворота следующего вида:

$$
Rotate(\theta) = \begin{bmatrix} \cos \theta & -\sin\theta & 0 \\ \sin \theta & \cos \theta & 0 \\ 0 & 0 & 1\end{bmatrix}
$$

Применим оператор над точкой и получим

$$
Rotate(\theta) \circ P_{(x,y)} = \begin{bmatrix} \cos \theta & -\sin\theta & 0 \\ \sin \theta & \cos \theta & 0 \\ 0 & 0 & 1\end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} x \cos \theta - y \sin \theta \\ x \sin \theta + y \cos \theta \\ 1 \end{bmatrix}
$$

Вы можете проверить на бумаге, использую тригонометрию, что все именно так и работает.

*PS: умножить на оператор слева вы не сможете, так как будут несовместные размеры матрицы и вектор-столбца. Идите на пару по алгебре, чтобы получить дополнительную информацию по данному вопросу.*

### Оператор масштабирования

Для растягивания вектора (точки) по осям применяют такую матрицу:

$$
Scale(s_x, s_y) = \begin{bmatrix} s_x & 0 & 0 \\ 0 & s_y & 0 \\ 0 & 0 & 1\end{bmatrix}
$$

Применим над вектором

$$
Scale(s_x, s_y) \circ P_{(x,y)} = \begin{bmatrix} s_x & 0 & 0 \\ 0 & s_y & 0 \\ 0 & 0 & 1\end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} x s_x\\ y s_y \\ 1 \end{bmatrix}
$$

### Оператор переноса

Для смещение точки по осям на $(\Delta x, \Delta y)$, применяется матрица:

$$
Translate(\Delta x, \Delta y) = \begin{bmatrix} 1 & 0 & \Delta x \\ 0 & 1 & \Delta y \\ 0 & 0 & 1\end{bmatrix}
$$

Применим перенос

$$
Translate(\Delta x, \Delta y) \circ P_{(x,y)} = \begin{bmatrix} 1 & 0 & \Delta x \\ 0 & 1 & \Delta y \\ 0 & 0 & 1\end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} x + \Delta x\\ y + \Delta y \\ 1 \end{bmatrix}
$$

### Композиция операторов

Если вам нужно последовательно применить операторы, например $(op_1, op_2, op_3, .. op_n)$ над точкой $P_{(x,y)}$, тогда последовательно умножайте слева предыдущий оператор на следующий. Это следует из [ассоциативности умножения матриц](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)).

$$
(op_3 \cdot (op_2 \cdot (op_1 \cdot P_{(x,y)}))) = (op_3 \cdot op_2 \cdot op_1) \cdot P_{(x,y)}
$$

Обращайте внимание но то, с какой стороны вы умножаете матрицы, так как матрицы не [коммутативны](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BC%D1%83%D1%82%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C) по умножению. То есть $x \cdot y \neq y \cdot x$ для матриц.

# Код задания

```c
// В этом задании вам НЕ понадобятся указатели и динамические массивы
// Все объекты принимаются и передаются через стек

#include <assert.h>
#include <math.h>
#include <stdio.h>

typedef struct {
  float matrix[3][3];
} Transformation;

typedef struct {
  float vector[3];
  // data[0] -> x
  // data[1] -> y
  // data[3] == 1
} Point;

Point NewPoint(float x, float y) {
  // TODO: создайте экземпляр структуры на стеке
  // заполните поля нужными значениями
}

Transformation NewZeroTransformation() {
  // TODO: Создайте матрицу трансформаций с нулями
  // это понадобится в умножении матриц
}

Transformation NewIdentityTransformation() {
  // TODO: создайте единичную матрицу трансформаций
}

Transformation NewTranslateTransformation(float x, float y) {
  // TODO: создайте матрицу переноса вдоль осей
  // Hint: используйте матрицу идентичности для простоты
}

Transformation NewScaleTransformation(float sx, float sy) {
  // TODO: создайте матрицу масштабирования вектора
  // Hint: используйте матрицу идентичности для простоты
}

float angle_to_radian(float angle) {
  // TODO: напишите функцию перевода градусов в радианы
}

/**
 * angle - угол поворота в градусах
 */
Transformation NewRotateTransformation(float angle) {
  // TODO: создайте матрицу поворота
  // Hint: используйте матрицу идентичности для простоты
  // Hint: используйте функции sinf и cosf из math.h
  // Hint: функции sinf и cosf используют радианы
}

Transformation Matmul(Transformation lhs, Transformation rhs) {
  // TODO: напишите матричное умножение для матриц lhs и rhs
  // Hint: используйте NewZeroTransformation, чтобы получить матрицу, заполненную нулями
}

Transformation Rotate(Transformation tr, float angle) {
  // TODO: Примените поворот к существующей трансформации
  // Hint: создайте трансформацию поворота и матрично умножьте две трансформации
}

Transformation Scale(Transformation tr, float sx, float sy) {
  // TODO: Примените масштабирование к существующей трансформации
  // Hint: создайте трансформацию масштабирования и матрично умножьте две трансформации
}

Transformation Translate(Transformation tr, float x, float y) {
  // TODO: Примените перенос вдоль осей к существующей трансформации
  // Hint: создайте трансформацию переноса и матрично умножьте две трансформации
}

Point Apply(Transformation tr, Point p) {
  // TODO: напишите функцию для применения трансформации над точкой
  // тут будет просто умножение матрицы на вектор-столбец
}

void test_identity_transform() {
  Transformation i = NewIdentityTransformation();
  Point p = NewPoint(42, 3);
  Point res = Apply(i, p);
  assert(res.vector[0] == 42);
  assert(res.vector[1] == 3);
}

void test_translate_transform() {
  Transformation i = NewTranslateTransformation(4, -5);
  Point p = NewPoint(42, 3);
  Point res = Apply(i, p);
  assert(res.vector[0] == 46);
  assert(res.vector[1] == -2);
}

void test_scale_transform() {
  Transformation i = NewScaleTransformation(0.5, 2);
  Point p = NewPoint(42, 3);
  Point res = Apply(i, p);
  assert(res.vector[0] == 21);
  assert(res.vector[1] == 6);
}

void test_combine_transform() {
  Transformation i = NewIdentityTransformation();
  i = Scale(i, 0.5, 2);
  i = Rotate(i, 90);
  i = Translate(i, 3, 5);
  Point p = NewPoint(1, 1);
  Point res = Apply(i, p);
  assert(res.vector[0] == 1);
  assert(res.vector[1] == 5.5);
}

void test_combine_transform_2() {
  Transformation i = NewIdentityTransformation();
  i = Rotate(i, 90);
  i = Scale(i, 0.5, 2);
  i = Translate(i, 3, 5);
  Point p = NewPoint(1, 1);
  Point res = Apply(i, p);
  assert(res.vector[0] == 2.5);
  assert(res.vector[1] == 7);
}

int main(void) {
  printf("START\n");
  test_identity_transform();
  test_translate_transform();
  test_scale_transform();
  test_combine_transform();
  test_combine_transform_2();
  printf("FINISH\n");
}
```