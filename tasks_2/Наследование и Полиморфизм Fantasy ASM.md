---
tag: cpp, ооп, полиморфизм
---

# Наследование и Полиморфизм. Fantasy ASM.

## Fantasy Assembler

![img](/images/asm0.png)

Да, в этой практике вы будете делать простой интерпретатор ассемблера, так как польский калькулятор и геометрические фигуры - заезженные и унылые задания (хотя мем про Квадрат и Прямоугольник неиллюзорно доставляет преподавателям и студентам).

[Шаблон проекта в repl.it тут](https://repl.it/@IlyaSiganov/Fantasy-Assembler#main.cpp)

## Кто кого наследует и зачем?

Чтобы ответить на этот вопрос нам нужно понять из чего состоит код программы на ассемблере:

```asm
; Программа считает значение факториала числа из регистра r0.
; Результат вычисления будет в регистре r1

mov r0 5   ; положили в регистр r0 число 5
mov r1 1   ; положили в регистр r1 число 1
mul r1 r0  ; умножили cодержимое регистра r1 на r0, а результат положили в r1
add r0 -1  ; сложили содержимое r0 и числа -1, а результат положили в r0
cmp r0 0   ; сравнили содержимое r0 с числом 0, результат сравнения лежит в специальном регистре f0
jgr -4     ; если в регистре f0 лежит 1, тогда прыгаем на 4 строчки назад иначе просто выполняем код дальше

; EOF. В r1 лежит факториал r0.
```

Как мы видим, есть следующие сущности:

- строчка кода
- регистры (`r0`, `r1`, `f0`и другие) (список регистров настоящего ARM для справки [azeria-labs.com/arm-data-types-and-registers-part-2/](https://azeria-labs.com/arm-data-types-and-registers-part-2/))
- оператор (`mov`, `mul`, `add`, `cmp`, `jgr` и другие)
- операнды (то, что стоит справа от оператора, типа аргументы функции)
- литералы (просто число, например `42`)
- интерпретатор, который выполняет строчки кода
- текущая строчка кода, которая выполняется (хранится в каком-то регистре)

Я бы выделил следующие сущности в терминах языка программирования:

- `IValue` - интерфейс иммутабельной сущности. Например, литерал.
- `IMutableValue` - интерфейс мутабельной сущности.  Например, регистр.
- `IOperation` - интерфейс любой операции.
- `Memory` - класс, который содержит состояние памяти: регистров и самого кода.
- `Interpreter` - класс, который отвечает за пошаговое выполнение всех строчек кода, которые хранятся в памяти.
- `LiteralValue` - конкретная реализация `IValue` для доступа к литералу.
- `RegisterValue` - конкретная реализация `IValue` и `IMutableValue` для доступа к регистру.
- `MovOp`, `AddOp`, `MulOp`, `CmpOp`, `JeqOp`, `JnqOp`, `JleOp`, `JgrOp`, `JmpOp`, `OrOp`, `AndOp`, `NotOp` - конкретные реализации операторов.

Пример использования этих классов:

```cpp
// Это тот самый код, который считает факториал числа в регистре r0
Interpreter interpreter;
Memory mem;

// "вставляем" код в память нашего fantasy-компьютера
// обратите внимание, что все операторы принимают на вход интерфейсы операндов. 
mem.PushOp(new MovOp(new ValueRegister(r0), new ValueLiteral(5))); // первый операнд обязан быть IMutableValue, а второй может быть просто IValue
mem.PushOp(new MovOp(new ValueRegister(r1), new ValueLiteral(1)));
mem.PushOp(new MulOp(new ValueRegister(r1), new ValueRegister(r0)));
mem.PushOp(new AddOp(new ValueRegister(r0), new ValueLiteral(-1)));
mem.PushOp(new CmpOp(new ValueRegister(r0), new ValueLiteral(0)));
mem.PushOp( new JgOp(new ValueLiteral(-4))); // например тут сказано, что можно подавать IValue

interpreter.Run(mem);

assert(mem.GetReg(r1) == 1 * 2 * 3 * 4 * 5);
assert(mem.GetReg(r0) == 0);
```

## Дополнительное задание

Вы можете реализовать максимально просто построчный парсер ассемблерного кода, чтобы можно было пользоваться вашей программой как настоящим интерпретатором и писать в консоли `./fantasy_asm --run code.asm` или хотя бы запустить код из строки.

**HINT:** Возможно вам поможет `stringstream` и кучка `switch-case` (а лучше словарей `map`). Комментарии не учитывать не обязательно.

Если интересно, то парсеры обычно пишут применяя паттерн абстрактный конечный автомат ([тыц1](http://senior-sigan.net/fcs-programming-technology/pages/practise_12) и [тыц2](http://senior-sigan.net/fcs-programming-technology/pages/practise_13))

![img](/images/asm1.jpg)

```cpp
auto code = R"(
  mov r0 5   ; положили в регистр r0 число 5
  mov r1 1   ; положили в регистр r1 число 1
  mul r1 r0  ; умножили cодержимое регистра r1 на r0, а результат положили в r1
  add r0 -1  ; сложили содержимое r0 и числа -1, а результат положили в r0
  cmp r0 0   ; сравнили содержимое r0 с числом 0, результат сравнения лежит в специальном регистре f0
  jgr -4
)";

Memory mem;

Parser parser(code);
while (parser.ParseLine()) {
  mem.PushOp(parser.GetCurrentOperation());
}

Interpreter interpreter;
interpreter.Run(mem);

assert(mem.GetReg(r1) == 1 * 2 * 3 * 4 * 5);
assert(mem.GetReg(r0) == 0);
```

### WHY???

Где такое может понадобиться в жизни?

Например, вы могли решить за 2 дня сделать игру с эмулятором выжигателя, программируемого ассемблером: 

[VychVyzhProm](https://catinthedark.itch.io/vychvyzhprom)

![img](/images/asm2.jpg)

## Справка по ассемблеру

Язык ассемблера (англ. assembly language) — машинно-ориентированный язык программирования низкого уровня. Его команды прямо соответствуют отдельным командам машины или их последовательностям.

Язык ассемблера позволяет программисту пользоваться алфавитными мнемоническими кодами операций, по своему усмотрению присваивать символические имена регистрам ЭВМ и памяти.

Команды языка ассемблера один к одному соответствуют командам процессора. Фактически, они и представляют собой более удобную для человека символьную форму записи — мнемокоды — команд и их аргументов.

### Набор команд

*Результат выполнения команд записывается в первый операнд.*

- `MOV {КУДА} {ОТКУДА}` - команда пересылки данных. Куда - это регистр, куда надо записать данные. Откуда - это регистр или литерал.
- `OR, AND, NOT`  - логические и побитовые операции. `OR X Y` эквивалентно `x |= y`.
- `ADD, MUL` - арифметические операции. Типичный синтаксис `ADD X Y` эквивалентно записи на си: `x += y`.
- `CMP X Y` - команда сравнения. Результат сравнения будет положен в специальный регистр состояния по правилам:

    ```cpp
    if (x==y){
      state = 0;
    } else if (x>y) {
      state = 1;
    } else {
      state = -1;
    }
    ```

- `JMP` - команды управления ходом выполнения. Их бывает много разны
  - `JMP L` - будет запущена строчка кода, находящаяся на L строк далее относительно текущей. L может быть отрицательным.
  - `JEQ L` (jump if equals)- прыгать на L, только если в регистре состояния лежит 0. (То есть прошлый вызов `CMP X Y` показал что `X==Y`)
  - `JGR L` (jump if greater)- прыгать на L, только если в регистре состояния лежит 1.
  - `JLE L`(jump if less)- прыгать на L, только если в регистре состояния лежит -1.
  - `JNE L` (jump no equals) прыгать если не равны

### Набор регистров

- R0 .. R9 - регистры общего назначения
- `R15` - program counter register - регистр, в котором хранится номер текущей строки выполнения кода
- `F0` - регистр флага статуса, куда записывается результат сравнения CMP.
- другие регистры мы не реализуем, хотя могли создать регистры для стека, и многое другое, см для интереса [https://azeria-labs.com/arm-data-types-and-registers-part-2/](https://azeria-labs.com/arm-data-types-and-registers-part-2/)

## Шаблон проекта

[Шаблон проекта в repl.it тут](https://repl.it/@IlyaSiganov/Fantasy-Assembler#main.cpp)

Я предлагаю следующий шаблон проекта, в котором есть объявления всех необходимых классов. Вам остается только внимательно прочитать комментарии к объявлениям методов и написать их реализации в cpp файлах.

Предполагается, что код в `.h` файлах менять **не нужно**. Ваш код должен быть только в `.cpp` файлах.

В `main.cpp` вы увидите несколько тестов.

Возможно, вам поможет этот стрим, где я писал калькулятор в обратной польской нотации.

[https://www.youtube.com/watch?v=3aMpifryO1A&feature=youtu.be](https://www.youtube.com/watch?v=3aMpifryO1A&feature=youtu.be)

Код со стрима про польский калькулятор - [https://github.com/senior-sigan/reverse_polish_calc_cpp](https://github.com/senior-sigan/reverse_polish_calc_cpp)
