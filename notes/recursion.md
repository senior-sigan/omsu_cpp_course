# Рекурсия

> Итерация свойственна человеку, рекурсия - божественна. Л. Питер Дойч

В этот раз посмотрим, как работать с функциями в Си. Изучим рекурсивные алгоритмы, напишем пару утилитных функций. Поработаем над передачей переменных через аргументы функции. Поймем саму суть циклов.

Прочитайте главы 1.2.1 и 1.2.2 книги "Структура и интерпретация компьютерных программ", страница 48.

TODO:

- добавить сравнение итерации через for и рекурсии
- добавить примеры про древовидную рекурсию
- добавить примеры с переполнением стека вызовов

## Примеры

```c
#include<stdio.h>

/**
 * В этих переменных копии переменных, 
 * которые были переданы как аргументы функции
 **/
int add(int a, int b) {
    return a + b;
}

// x - массив целых чисел. В переменной x хранится копия массива, 
// который был передан как аргумент функции;
int scalar_mul(int x[], int y[], unsigned int size) {
    int accum = 0;
    for (int i = 0; i < size; i++) {
        accum += x[i]*y[i];
    }
    return accum;
}

// Рекурсия!!!
// Функция может вызвать саму себя.
int recursion(int i) {
    if (i <= 0) return 0; // Главное не забудьте указать условие, когда надо остановиться.
    return i + recursion(i - 1);
}

int main(void) {
  int a = 100500; // эта переменная a не имеет отношению к аргументу функции add 
  int x = 42;
  int y = 2;
  int z = add(x, y); // теперь a = x, b = y.
  printf("%d\n", z); // z == 44
  
  int arr1[] = {1,2,3,4,5}; // объявили и сразу проинициализировали массив
  int arr2[] = {5,4,3,2,1};
  printf("%d\n", scalar_mul(arr1, arr2, 5)); // 1*5+2*4+3*3+4*2+5*1
  
  printf("%d\n", recursion(5)); // 5 + 4 + 3 + 2 + 1 + 0
}
```
