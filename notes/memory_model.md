# Модель памяти в Си/C++

**ВНИМАНИЕ. Этот еще черновик. Изложение сумбурное, но в целом правильное. Нужно больше примеров. Нужно упорядочить изложение.**

- Что такое переменная? Зачем разные типы?
- Таблица сопоставления имени переменной и адреса в памяти
- rvalue и lvalue. Присвоение одной переменной другой
- Что такое указатели
- Указатели на переменные разных типов
- Взятие адреса, разыменование указателя
- Передача аргументов в функцию через указатель
- Массивы и указатели
- Арифметика указателей
- Связь между массивами и указателями
- Память - регистры, стек, куча
- Магия на полях структур, отрицательные индексы массива, перемещение по стеку
- Строки: массивы символов vs нуль-терминальные строки
- Динамическое выделение памяти: malloc, calloc, alloc(стек), new
- Указатели на функции и зачем оно нужно

Переменная - это имя для некоторой области памяти (имя переменной в терминах языка это идентификатор). Каждая переменная имеет тип, чтобы сказать компилятору сколько нужно памяти для неё выделить и как интерпретировать те биты, что лежат в этой области памяти.

У переменных есть еще область видимости (scope) - то есть пределы в которых эта переменная имеет смысл. И время жизни (extent, связывание), определяющее когда программа создает и удаляет перменную.

Переменные можно объявлять:

- вне функции. Global scope. Global extent.
- внутри списка аргументов функции. Local scope. Bounded extent. Живет только с момента когда функция была вызвана, до момента, когда функция завершит выполнение.
- В начале любого блока кода, обрамленного фигурными скобками. Local scope для блока. Bounded extent - время жизни функции, содержащей этот блок.

Storage class qualifiers - можно менять то, как переменная будет храниться с помощью специальных ключевых слов. Тут оказывается, что exten бывает:

- automatic extent - переменная живет во время жизни функции. Уничтожается за счет смещения указателя стека.
- static extent - переменная живет всё время жизни программы.

Модификатор `const` делает так, что область памяти нельзя менять.

Существует 3 способа хранения объектов:

- автоматический
- статический
- динамический

Переменная - это нечто с именем, значение чего может изменяться. Компилятор и линковщик оперируют переменными, ассоциируя с ними определенные блоки памяти, в которых хранятся сами значения. Размеры и правила интерпретации данных в этих блоках памяти определяются типом переменных. Так например на 32 битной машине тип int занимает 4 байта и хранит 2^32 разных чисел (отрицательных в том числе). Кстати размер переменной можно узнать через sizeof  на этапе компиляции.

Когда мы декларируем переменную `int k;`, мы сообщаем компилятору имя и тип переменной. По типу он определяет сколько места в памяти надо зарезервировать, а для имени он фиксирует в таблице символьных имен ассоциацию между символом и адресом этого блока в памяти.

И далее когда мы пишем `k=2;` , мы ожидаем, что на стадии выполнения по адресу, с которым связана переменная с именем `k`, будет записано в память представление числа `2`. Кстати, `k` - это `lvalue` а `2` - это `rvalue`. Об этом часто в документации пишут.

> An object is a named region of storage; an lvalue is an expression referring to an object.

Как бы lvalue - это выражение, ссылающееся на объект в памяти.

Когда мы пишем

```c
int j, k;
k = 2;
j = 7;
k = j;
```

То k воспринимается как lvalue, а j как rvalue, поэтому в k будет скопировано значение, которое лежит в блоке памяти для j. Так как k типа int, то скопировано будет 4 байта. Если бы было char, то 1 байт.

Если мы хотим переменную, которая будет себя вести как lvalue - то есть как адрес, то тут на помощь приходит так называемый указатель. В си у указателя есть еще и тип, который обозначает на какой тип в памяти он ссылается.

Когда мы просто объявляем указатель `int* ptr` мы не присваиваем ему ничего. Но куда тогда он указывает? Никуда - это `NULL` pointer.

Чтобы положить в переменную типа указатель адрес другой переменной мы применяем оператор взятия адреса `int* ptr = &k`. По факту & получет lvalue, хотя это rvalue.

Чтобы обратиться к самому значению, на которое указывает указатель, надо применять оператор `*` разыменования указателя. `*ptr=42`. Но не только для этого. Допустим в памяти у нас есть блок размером 40 байт. То есть он подходит для размещения 10 четырехбайтовых переменных, например int.

Что тогда будет означать выражение `ptr +1`? Компилятор знает, что он работает с int, поэтому он может прибавить адресу переменной 4 байта. То есть если гипотетически `ptr==100` тогда `ptr+1==104` То есть автоматически произошла "арифметика указателей". Поэтому ptr+1 ссылается на следующее число в памяти. Из-за того что блок из 10 переменных расположены в памяти последовательно(нам это гарантируют), это приносит любопытную взаимосвязь между указателем и массивом. 

Пусть `int arr[] = {11,-2,33,42,100500}` автоматический массив из 5 переменных типа int. 

Для чего у указателя есть тип? Например `int*`. Для того, чтобы когда мы напишем `*ptr=42` компилятор знал, сколько байт нужно скопировать из rvalue и положить по адресу.

---

- Языки ассемблера
- Низкоуровневые языки: C
- Где-то между: C++
- Высокоуровневые: Java, Python, Lisp

В языках ассемблера ты знаешь что и где хранится. Вот это регистр. Вот те данные в стеке, вот те в "куче". Ты сам их туда вручную отправил.

Низкоуровневые языки стараются снять с программиста рутину по ручному управлению памяти. Программист может просто создать переменную, а уж компилятор решит куда ее положить - в стек, в регистр. Вызов функций тоже проще. НО остался ручной выбор - хранить данные в стеке, в куче, в константной секции. 

В высокоуровневых языках снимают даже эти вопросы, так как работа, что со стековыми, что с данными на куче выглядит одинаково.

С++ где-то по-середине, потому что механизмы самого же языка, позволяют это скрыть. Новый стандарты языка этому способствуют. Можно не использовать указатели в явном виде и не мучаться по поводу очистки памяти кучи, так как это делают умные указатели. `new` и `delete` позволяют через специальные аллокаторы скрывать то, где будут данные и как они будут выделены.

## Литература

- [https://en.cppreference.com/w/c/language/value_category](https://en.cppreference.com/w/c/language/value_category)
- [https://en.cppreference.com/w/c/language/object](https://en.cppreference.com/w/c/language/object)
- [https://en.cppreference.com/w/c/language/memory_model](https://en.cppreference.com/w/c/language/memory_model)
- [https://en.cppreference.com/w/c/language/type](https://en.cppreference.com/w/c/language/type)
- [https://en.cppreference.com/w/c/language/pointer](https://en.cppreference.com/w/c/language/pointer)
- [https://ru.wikipedia.org/wiki/Модель_памяти_в_языке_Си](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_%D0%B2_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5_%D0%A1%D0%B8)
- [7. Memory : Stack vs Heap](https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html)
- [What and where are the stack and heap?](https://stackoverflow.com/a/80113)
- [8. Pointers](https://www.gribblelab.org/CBootCamp/8_Pointers.html)
- [Arrays and Pointers](http://c-faq.com/aryptr/index.html)
- [Stanford C programming. - YouTube](https://www.youtube.com/playlist?list=PLD28639E2FFC4B86A)
- [Cheatsheet-c](https://courses.cs.washington.edu/courses/cse351/14sp/sections/1/Cheatsheet-c.pdf)
- [CS223/Notes](http://www.cs.yale.edu/homes/aspnes/pinewiki/CS223(2f)Notes.html)
- [A Tutorial on Pointers and Arrays in C](http://home.netcom.com/~tjensen/ptr/pointers.htm)
- [new expression - cppreference.com](https://en.cppreference.com/w/cpp/language/new)
- [malloc - cppreference.com](https://en.cppreference.com/w/c/memory/malloc)
