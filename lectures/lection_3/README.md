# Лекция 3. Наследование и Полиморфизм

- Наследование классов. Зачем?
- Наследование как отношение на множествах.
- Полиморфное поведение (пример целые числа, рациональные, вещественные, комплексные)
- Доступ к полям класса наследниками
- Порядок конструирования объектов в цепочке наследников
- Порядок уничтожения объектов в цепочке наследников
- Наследование без виртаульного метода
- Виртуальные методы
- Виртуальный деструктор
- Чисто виртуальные класса-интерфейсы (=0)
- Override виртуальных функций (с и без ключевого слова override)
- Upcast. Downcast (static vs dynamic cast). Замена типа объектов на класс предка или интерфейса. Принцип подстановки Лисков.
- перекрытие полей, доступ к перекрытому полю базового класса (Base::field)

## Разделение кода по файлам

- Зачем разделять код на header (.hpp/.h) и source (.cpp/.c)?
- Раздельная компиляция
- Препроцессинг
- Компоновка
- Forward declaration
- Циклические зависимости и их разрешение с помощью Forward Declaration

## Теория

Зачем нужно наследование?

- Введение логической иерархии между классами (Cat, Dog <= Animal);
- Решение проблемы дублирования между однотипными структурами;
- Универсальные функции, работающие с базовыми классами-родителями (DoMeal).

Отношение публичного наследования объявляются так: 
`class TDerived : public TBase {...}`.

При таком публичном наследовании у класса-наследника появится в том числе доступ к полям и методам базового класса, от которого он унаследован.

Списки инициализации: `Cat() : Animal("cat"){} // конструктор Cat`.

Полиморфизм - как использовать разные объекты, имея один интерфейс. Или как не меняя код вообще изменить его поведение.

## Примеры

### игра с машинками

- машинки
- препятствия
- призы

### стековый калькулятор

- parser
- token
- operations
- ...
