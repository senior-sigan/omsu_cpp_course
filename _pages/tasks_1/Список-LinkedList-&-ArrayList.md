---
replit: https://repl.it/@IlyaSiganov/List#main.c
tag: выделение памяти, структура, структуры данных, указатели
---

# Список: LinkedList & ArrayList

Можно написать на Си со структурами и функциями, а можно на С++ с методами и интерфейсами, если знаете как.

На этой практике мы познакомимся с Абстрактными Типами Данных. Разберем Список, как один из видов АТД. Напишем две реализации Списка - Связный Список и Список на основе массива. Проведем бенчмарк скорости работы двух реализаций в разных задачах.

## Теория

АТД - это математическая модель некоторого типа данных, где тип определяется некоторым поведением, то есть возможными значениями, которые он может принимать, возможными операциями над ним и поведением этих операций. Вся внутренняя структура такого типа скрыта от пользователя. В этом и заключается абстракция. Например, нам нужен тип данных, который хранит последовательности чисел. Нам не важно то, как реализовано хранения данных, нам важно чтобы мы могли добавлять в последовательность новые числа, получать доступ к ним. Когда мы пишем программу, мы не хотим концентрироваться на реализациях этих абстракций, мы хотим чтобы они работали эффективно и без ошибок. Например, использование АТД Список позволит нам не думать о выделении и очистке памяти.

### Список

Рассмотрим матмодель списка - множество объектов, упорядоченное по индексу элемента в списке. Мы хотим иметь возможность применять следующий операции над списком:

- `GetAt(index)` - взять элемент из списка по индексу
- `Insert(index, element)` - вставить элемент по индексу
  - `Append(element)` - вставить элемент в конец списка(стека)
  - `Prepend(element)` - вставить элемент в начало списка(очереди)
- `Delete(index)` - удалить элемент по индексу
  - `Pop()` - удалить элемент с конца списка(стека) и получить этот элемент
  - `Dequeue()` - удалить элемент с начала списка(очереди)
- `Length()` - получить длину списка

Содержимое файла-интерфейса `list.h`. Его менять нельзя, подключайте его в ваших реализациях с помощью `#include "list.h"`.

```c
// это файл list.h
#ifndef LIST_LIST_H
#define LIST_LIST_H

typedef struct List List; // не специфицированная структура, конкретные реализации должны быть описаны в c-файлах
List *NewList(); // создание пустого списка

void Append(List *, int); // вставка элемента в конец списка
void Prepend(List *, int); // вставка элемента в начало списка
void AppendAll(List *, const List *); // вставить все элементы одного списка в конец другого. Происходит глубокое копирование листа справа. Если удален правый лист, то у левого листа данные не исчезают.
void InsertAt(List *, int, int); // вставка элемента после индекса

void RemoveAt(List *, int); // удаление элемента по индексу
void RemoveAll(List *); // удаление всех элементов из списка

int Pop(List *); // удаление элемента с конца списка, функция возвращает удаленный элемент
int Dequeue(List *); // удаление элемента с начала списка, функция возвращает удаленный элемент

int Length(const List *); // вычисление длины списка
int GetAt(const List *, int); // взятие элемента списка по индексу

#endif //LIST_LIST_H
```

Реализовать Список можно разными способами:

- линейно связный список
- список на основе массива.

### Линейно связный список

![https://s3.amazonaws.com/hr-challenge-images/17168/1456961238-28488bfa0d-LinkedListExplanation.png](https://s3.amazonaws.com/hr-challenge-images/17168/1456961238-28488bfa0d-LinkedListExplanation.png)

Список можно представить в виде связанных объектов, каждый из которых хранит полезную нагрузку и имеет указатель на следующий элемент списка. Можно представить вагоны поезда, как связный список.

Используйте следующий код для написания реализации:

```c
// linked_list.c
#include "list.h"

// В узле списка хранится само значение value и указатель на следующий узел.
// Эту структуру пользователи списка не должны видеть, так как она относится к внутренней реализации.
typedef struct Node_ {
  int value; // само значение, которое хранит узел
  struct Node_ *next; // указатель на следующий узел
} Node;

// Пользовательская структура, которая скрывает механизм хранения данных.
struct List {
  Node *head; // указатель на голову списка
  Node *tail; // указатель на хвост списка
  // если нужно, то добавьте дополнительные поля
};
```

### Список на основе массива

Очевидно, можно реализовать список на основе непрерывного куска памяти - обычного массива. В этом случае мы как разработчики списка скроем от пользователя машинерию по выделению памяти при добавлении новых элементов в массив или по очистке памяти. Основная сложность тут состоит в том, чтобы как можно реже вызывать операции по довыделению памяти и не поймать ошибку, когда ОС не может выдать нам непрерывный кусок памяти большого размера.

Вам придется использовать механизмы перевыделения памяти `realloc`.

Используйте следующий код для написания реализации:

```c
// array_list.c
#include "list.h"

// Пользовательская структура, которая скрывает механизм хранения данных.
struct List {
  int* array; // динамический массив, в котором будут раниться все данные
  int length; // размер списка: последний занятый индекс в array
  int capacity; // ёмкость списка: реальный размер массива array
  // если нужно, то добавьте дополнительные поля
};
```

## Задание

Используя описанные выше прототипы функций в файле `list.h`, необходимо сделать две разные реализации Списка: на основе массива, на основе связного списка. В результате вашей работы у вас будут следующие файлы с реализациями: `array_list.c` и `linked_list.c`.   В файле `main.c` напишите тесты, которые проверяют корректность работы всех функций из `list.h`. Если тест обнаруживает ошибку, то программа должна сразу же завершить с сообщением об ошибке. Например:

```jsx
#include "list.h"

void AssertEq(int expected, int actual, const char* msg) {
  if (expected != actual) {
    printf("Test failed: %s\n expected %d but got %d\n", msg, expected, actual);
    exit(-1);
  }
}

int main(void) {
  List* list = NewList();
  AssertEq(0, Length(list), "empty list length should be zero");
  Append(list, 42);
  AssertEq(1, Length(list), "Length([42]) should be 1");
  AssertEq(42, GetAt(list, 0), "GetAt([42], 0) should be 42");

  //TODO: Здесь куча разных ваших тестов!!!
}   
```

Чтобы скомпилировать проект запустите следующие команды:

```bash
gcc -Wall -Werror -Wextra main.c linked_list.c list.h -o linked_list.out
gcc -Wall -Werror -Wextra main.c  array_list.c list.h  -o array_list.out

./linked_list.out # запуск тестов для связного списка
./array_list.out  # запуск тестов для списка на массивах
```

## Критерии приемки

- Прототипы функций из `list.h` менять нельзя
- Из библиотечных функций разрешены только функции ввода-вывода и работы с памятью.
- В `linked_list.c` и `array_list.c` должны быть реализованы все прототипы функций из `list.h`
- Дополнительные и вспомогательные функции писать можно, но они должны быть помечены как `static`.
- Добавлять дополнительные поля в структуры `List` и `Node` можно.
- В функции main должны быть написаны тесты на все функции из `list.h`
- Тесты должны проверять граничные условия. То есть одного теста на одну функцию не достаточно. Как минимум 3 теста на функцию.
- Программа должна компилироваться с флагами `gcc -Wall -Werror -Wextra`
- Не должно быть утечек памяти

## Литература

Вы можете посмотреть следующие материалы, чтобы лучше понять, как решить задачу:

- [www.geeksforgeeks.org/data-structures/linked-list/](https://www.geeksforgeeks.org/data-structures/linked-list/)
- [tproger.ru/translations/linked-list-for-beginners/](https://tproger.ru/translations/linked-list-for-beginners/)
- [www.ibm.com/developerworks/ru/library/l-data_structures_02/index.html](https://www.ibm.com/developerworks/ru/library/l-data_structures_02/index.html)

![картинка](/images/linkedlist.png)

После этой лабы, думаю, можно приниматься за реализацию своего Blockchain.

[https://www.youtube.com/watch?v=zQI3FyWm144](https://www.youtube.com/watch?v=zQI3FyWm144)
